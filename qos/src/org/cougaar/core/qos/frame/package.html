<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Frames and FrameSets</title>
</head>

<body>

Overview: Frames are a lightweight form of knowledge representation
supporting multiple inheritance hierarchies and code generation.

<h2>Frames and FrameSets</h2>

<p>A <b>{@link org.cougaar.core.qos.frame.DataFrame}</b>
is a unit of knowledge, consisting of a type specification (what kind
of frame it is) and a set of name-value pairs representing its current
state.  The pairs, also known as <b>slots</b>, can change dynamically
at runtime.  The type of any given DataFrame is fixed for the lifetime
of the Frame.  DataFrames can be treated as beans, more or less, with
the standard form of accessor methods and with support for
property-change notifications.  This allows DataFrames to be shadowed
in Jess, which in turn means that rules can use slot values of
DataFrames</p>

<p> A DataFrame can represent either an entity or a binary
relationship between other DataFrames.  In the latter case, each of
two parts of the binary relation are specified by a type/slot/value
triple which is expected to match at most one DataFrame (i.e., at most
one frame of the given type should have the given value in the given
slot).  NB:  In the current release we assume that slots used in
relationship matching are immutable, but this immutability is not
enforced.</p>

<p> The meta-data in the Cougaar frame system is derived from
<b>prototypes</b> described in xml.  These prototypes correspond to
the types of the DataFrames, and are organized as a single-inheritance
hierarchy.  Prototypes include declarations of the slots they include,
with optional default values.  </p>

<p>Prototype meta-data is used for several purposes.  First, it's used
to generate Java classes for the types.  DataFrame instances at run
time will be instances of one of these generated classes.  In
addition, the prototypes are also accessible at runtime as frames
themselves, in particular as <b>{@link
org.cougaar.core.qos.frame.PrototypeFrame}</b> instances. </p>


<p>A <b>{@link org.cougaar.core.qos.frame.FrameSet}</b> is simply an
organized collection of DataFrames and PrototypeFrames.  The latter
can come and go dynamically; the former are associated with the
FrameSet when it's made and are fixed for the life of the FrameSet
(the structure is fixed -- specific slot values in PrototypeFrames are
not).  The main job of a FrameSet is to provide a well-defined
subspace of Frames.  It's also used to cache interesting
relationships, including the relationship between a DataFrame and its
Prototype, as well as the <a href="#containment">containment</a>
relationshops.</p>

<p>FrameSets can be created and populated via xml using the <b>{@link
org.cougaar.core.qos.frame.FrameSetService}</b>, and existing
FrameSets can be found with that service.  [more] </p>

<p> <a name="containment"></a> One of the novel features of the
Cougaar frame system is that it supports two independent
hierarchies. In addition to the prototype hierarchy, the Cougaar frame
system a second single-inheritance hierarchy known as
<b>containment</b>. Containment is a special relationship used to
augment slot value lookup at runtime.  As one might expect, DataFrames
can include a frame-specific value for any given slot.  If it does, no
further work is required.  If it doesn't, the prototype hierarchy is
searched for a default value or for a path specification (see <a
href="#paths">below</a> for more on paths).  If this fails as well,
the containment hierarchy can then be searched.  This allows a
DataFrame to have virtual access to slots defined by its logical
container.  The containment relation is defined as part of FrameSet
and fixed when the FrameSet is created.  This relation is another
example of caching handled by the FrameSet. </p>


<a name="paths"></a> <p>Another novel features of the Cougaar frame
system is the <b>{@link org.cougaar.core.qos.frame.Path}</b>
specification.  The description of any given slot in a prototype can
indicate that the value of that slot for some frame F is determined by
following a particular path from F a runtime.  A Path represents a
kind of encapsulated visitor pattern.  It consists of an ordered
series of <b>Forks</b> and a slot.  Each Fork refers to a relation and
a role.  This allows any given frame to follow a path, one
relationship at a time, to any related frame, arbitrarily far away.
When the final frame in the path is reached, the given slot value is
returned as the value of the original slot reference. NB: Although
DataFrames generally act like beans, including property-change
support, Path-valued slots are an exception at the moment: if the
value of Path-valued slot changes, listeners will not be notified. We
hope to deal with this in a future release. <p>

<h2>XML Specification</h2>

<p>FrameSets and Frames can be loaded into Cougaar via xml file.  This
section describes the relevant XML entities, their attributes and
their semantic interpretation.

<dl>

  <dt><b>frameset</b></dt>

  <dd>A <code>frameset</code> entity is used to describe a FrameSet.
    It has three required attributes.  The <b>frame-inheritance</b>
    describes the prototype inheritance structure.  The only supported
    value right now is "single" (i.e., single inheritance).  The
    <b>container-relation</b> attribute specifies which relation
    prototype defines the containment hierarchy.  Any defined relation
    prototype can be specified here.  The <b>package</b> attribute is
    used by the code generator: the classes generated for this
    frameset's prototypes will be put in the given package and the
    files will be written to the corresponding directory stucture,
    following standard Java conventions.<p>

  </dd>

  <dt><b>prototypes</b></dt>

  <dd> A <code>prototypes</code> entity can be used to group
    <code>prototype</code> entities.  It has no attributes and is
    not required.  Ordinarily a <code>prototypes</code> entity would
    be within a <code>frameset</code> entity in an XML file. But it
    can also be at the top level if the file is being read in to an
    existing FrameSet.<p>
    
  </dd>

  <dt><b>prototype</b></dt>

  <dd>A <code>prototype</code> entity defines a PrototypeFrame.  It
    has one required attribute, <b>name</b>, which is the name of
    the prototype.  It also supports three optional attributes:
    <b>prototype</b>, which specifies the "super" of this one;
    <b>container</b>, which specifies the prototype of frames that
    can act as containers for frames of this prototype; and
    <b>doc</b>, which will be used as javadoc in the generated
    class.  The remaining structure of a prototype is specified by
    the <a href="#slot"><code>slot</code></a> entities it contains.
    <p>

  </dd>

  <dt><b>relation-prototype</b></dt>

  <dd>A <code>relation-prototype</code> entity defines a
    PrototypeFrame representing a relationship.  The attributes
    are a superset of the attributes of <code>prototype</code>
    entities.  The additional attributes, all optional, are
    <b>parent-prototype</b>, <b>parent-slot</b>,
    <b>child-prototype</b> and <b>child-slot</b> </p>

  </dd>

  <dt><b>path</b></dt>

  <dd>A <code>path</code> entity defines a <a
    href="#paths">Path</a>.  It has one required attribute,
    <b>name</b>.  The entities it contains are any number of
    <code>forks</code> (order is significant) followed by one
    <code>slot</code>.  The <code>slot</code> entity in this case is
    simply a reference by name to a <code>slot</code> defined in a
    prototype.<p>

  </dd>

  <dt><b>fork</b></dt>

  <dd>A <code>fork</code> entity defines a "hop" in its enclosing
  <code>path</code>, where a hop consists of a relation prototype and
  a role the next object on the path should play in that
  relationshoip.  Correspondingly, a <fork> entity has two required
  attributes: <code>relation</code> (the relation prototype name) and
  <code>role</code> ("parent" or "child").<p>

  </dd>
  
  
  <a name="slot"></a><dt><b>slot</b></dt>

  <dd> A <code>slot</code> entity is used within
    <code>prototype</code> entity to define one of the prototype's
    named fields. It has one required attribute, <b>name</b>, which
    is the name of the slot, and a range of optional attributes:

    <dl>

      <dt><b>immutable</b></dt>

      <dd> This boolean valued attribute indicates whether or not
	the value of the slot in any given DataFrame can be chaged
	after initialization.  The default is "false" (ie, values
	can be changed after initialization).
	<p>
	
      </dd>

      <dt><b>member</b></dt>

      <dd>This boolean valued attribute indicates whether or not the
	generated code for this slot treats it as a data member or
	as a property.  The former is more efficient for slots whose
	value is usually frame-specific, the latter is more
	efficient for slots whose value is usually defaulted. The
	default for this attribute is "true".
	
	<p>Other slot attributes can render this one irrelevant.  In
	particular, if a slot has a <code>path</code>, it will never
	be a data member, regardless of the setting of this
	attribute.  Conversely, if the slot is declared to have a
	simple <code>type</code>, or if it's declared to be
	<code>transient</code>, it will always be a data member,
	regardless of the setting of this attribute.

	<p>

      </dd>

      <dt><b>notify-blackboard</b></dt>

      <dd>This attribute specifies whether or not a change should be
	published on the Blackboard when the slot value changes.  The
	default is "true".  <p>

      </dd>

      <dt><b>notify-listeners</b></dt>

      <dd>This attribute specifies whether or not PropertyChange
	listeners should be notified when the slot value changes.  The
	default is "true".  <p>

      </dd>
      
      <dt><b>path</b></dt>

      <dd> The presence of this attribute indicates that the default
	value for this slot is computed by following a path.  The
	value of the attribute is the name of path.  If a
	<code>path</code> attribute is present, the slot cannot be a
	<code>member</code>.  <p>

      </dd>

      <dt><b>transient</b></dt>

      <dd>This boolean valued attribute indicates whether or not the
	corresponding data member in the generated class will be
	declared transient.  The default is "false".  Transient
	slots are always <code>members</code>. <p>

      </dd>

      <dt><b>type</b></dt>

      <dd> This attribute is used to specify the Java type of values
	of this slot.  The default is "String".  Other possible
	values are "int", "long", "float", "double", "boolean",
	"Integer", "Long", "Float", "Double" and "Boolean". Slots
	with simple types must be <code>members</code>. See below
	for more on slot types.<p>

      </dd>

      <dt><b>value</b></dt>

      <dd>This attribute gives a default value of the slot.  The
	value can be any string.  If a slot has neither a value nor
	a path attribute, then the slot has no default value.  In
	this case, the generated accessor code will issue a warning
	if it has no frame-specific value for this slot.  <p>
      </dd>

      <dt><b>warn</b></dt>

      <dd>This boolean valued attribute indicates whether or not a
	warning is generated at runtime if the slot has no
	value. The default for this attribute is "true".  <p>

      </dd>


    </dl>

    <p>Slot entities also appear in paths, but as a references
    rather than definitions: the only relevant attribute in this
    context is <b>name</b>.  <p>

  </dd>


  <dt><b>frames</b></dt>

  <dd> A <code>frames</code> entity can be used to group
    <code>frame</code> entities.  It has no attributes and is not
    required.  Ordinarily a <code>frames</code> entity would be within
    a <code>frameset</code> entity in an XML file. But it can also be
    at the top level if the file is being read in to an existing
    FrameSet.<p>

  </dd>
  
  <dt><b>frame</b></dt>

  <dd>A <code>frame</code> entity describes a DataFrame.  It has one
    required attribute, <b>prototype</b>, which must name a
    PrototypeFrame in the same FrameSet.  The sub-entities are simply
    slot names, the content of which is the frame's initial value for
    that slot.  <p>

  </dd>


</dl>

</body>
</html>
